<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_75) on Thu Feb 12 23:19:10 AEDT 2015 -->
<title>KdTree</title>
<meta name="date" content="2015-02-12">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="KdTree";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../infodynamics/utils/IntArrayWrapper.html" title="class in infodynamics.utils"><span class="strong">Prev Class</span></a></li>
<li><a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?infodynamics/utils/KdTree.html" target="_top">Frames</a></li>
<li><a href="KdTree.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">infodynamics.utils</div>
<h2 title="Class KdTree" class="title">Class KdTree</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">infodynamics.utils.NearestNeighbourSearcher</a></li>
<li>
<ul class="inheritance">
<li>infodynamics.utils.KdTree</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="strong">KdTree</span>
extends <a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></pre>
<div class="block">K-d tree implementation to be used for fast neighbour searching
  across several (multi-dimensional) variables.
 Norms for the nearest neighbour searches are the max norm between
  the (multi-dimensional) variables, and either max norm or Euclidean
  norm (squared) within each variable.</div>
<dl><dt><span class="strong">Author:</span></dt>
  <dd>Joseph Lizier (<a href="joseph.lizier at gmail.com">email</a>,
 <a href="http://lizier.me/joseph/">www</a>)</dd>
<dt><span class="strong">See Also:</span></dt><dd><a href="http://en.wikipedia.org/wiki/K-d_tree">K-d tree page on wikipedia</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested_class_summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected class&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a></strong></code>
<div class="block">Protected class to implement nodes of a k-d tree</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected double[][][]</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#dimensionToArray">dimensionToArray</a></strong></code>
<div class="block">Maps dimension number (first index) to which
  double[][] array holds the data for this dimension,
  and which index we use in that array (dimensionToArrayIndex).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[]</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#dimensionToArrayIndex">dimensionToArrayIndex</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[]</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#dimensionToVariableNumber">dimensionToVariableNumber</a></strong></code>
<div class="block">Variable at index i in the full joint set 
 corresponds to high level variable
 dimensionToVariableNumber[i]; i.e.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[][]</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#masterSortedArrayIndices">masterSortedArrayIndices</a></strong></code>
<div class="block">For each dimension dim, sortedArrayIndices[dim] is an array
  of indices to the data in sourceObservations and destObservations,
  sorted in order (min to max) for the dimension dim;
  plus we have a spare dimension for a temporary array.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected double[][][]</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#originalDataSets">originalDataSets</a></strong></code>
<div class="block">Cached reference to the data the tree is constructed from.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#rootNode">rootNode</a></strong></code>
<div class="block">The root node for this k-d tree</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#totalDimensions">totalDimensions</a></strong></code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="fields_inherited_from_class_infodynamics.utils.NearestNeighbourSearcher">
<!--   -->
</a>
<h3>Fields inherited from class&nbsp;infodynamics.utils.<a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></h3>
<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#normTypeToUse">normTypeToUse</a></code></li>
</ul>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../infodynamics/utils/KdTree.html#KdTree(double[][])">KdTree</a></strong>(double[][]&nbsp;data)</code>
<div class="block">Construct the k-d tree from a set of double[][] data.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colOne"><code><strong><a href="../../infodynamics/utils/KdTree.html#KdTree(int[],%20double[][][])">KdTree</a></strong>(int[]&nbsp;dimensions,
      double[][][]&nbsp;data)</code>
<div class="block">Construct the k-d tree from a <b>set</b> of double[][] data,
 considered jointly.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#constructKdTree(int,%20int,%20int,%20int[][])">constructKdTree</a></strong>(int&nbsp;currentDim,
               int&nbsp;startPoint,
               int&nbsp;numPoints,
               int[][]&nbsp;sortedArrayIndices)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsStrictlyWithinR(int,%20double,%20int,%20boolean[])">countPointsStrictlyWithinR</a></strong>(int&nbsp;sampleIndex,
                          double&nbsp;r,
                          int&nbsp;variableAlreadyTested,
                          boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean,%20int,%20boolean[])"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsStrictlyWithinRs(int,%20double[])">countPointsStrictlyWithinRs</a></strong>(int&nbsp;sampleIndex,
                           double[]&nbsp;rs)</code>
<div class="block">Count the number of points strictly within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsStrictlyWithinRs(int,%20double[],%20int,%20boolean[])">countPointsStrictlyWithinRs</a></strong>(int&nbsp;sampleIndex,
                           double[]&nbsp;rs,
                           int&nbsp;variableAlreadyTested,
                           boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean,%20int,%20boolean[])"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinOrOnR(int,%20double,%20int,%20boolean[])">countPointsWithinOrOnR</a></strong>(int&nbsp;sampleIndex,
                      double&nbsp;r,
                      int&nbsp;variableAlreadyTested,
                      boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean,%20int,%20boolean[])"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinOrOnRs(int,%20double[])">countPointsWithinOrOnRs</a></strong>(int&nbsp;sampleIndex,
                       double[]&nbsp;rs)</code>
<div class="block">Count the number of points within or at norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinOrOnRs(int,%20double[],%20int,%20boolean[])">countPointsWithinOrOnRs</a></strong>(int&nbsp;sampleIndex,
                       double[]&nbsp;rs,
                       int&nbsp;variableAlreadyTested,
                       boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean,%20int,%20boolean[])"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean)">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">Count the number of points within norm r for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean,%20boolean[])">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean,%20int,%20boolean[])">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  int&nbsp;variableAlreadyTested,
                  boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with an additional factor as follows.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20int,%20boolean)">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  double&nbsp;r,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however any nodes within dynCorrExclTime are excluded from
 the search.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean)">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean,%20boolean[])">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  boolean[]&nbsp;additionalCriteria)</code>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean,%20int,%20boolean[])">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  boolean&nbsp;allowEqualToR,
                  int&nbsp;variableAlreadyTested,
                  boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20int,%20boolean)">countPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                  <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                  int&nbsp;level,
                  double&nbsp;r,
                  int&nbsp;dynCorrExclTime,
                  boolean&nbsp;allowEqualToR)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean)"><code>countPointsWithinR(int, KdTreeNode, int, double, boolean)</code></a>
 however excludes points within dynCorrExclTime of node
 from being counted.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean)">countPointsWithinRs</a></strong>(int&nbsp;sampleIndex,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR)</code>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean,%20int,%20boolean[])">countPointsWithinRs</a></strong>(int&nbsp;sampleIndex,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR,
                   int&nbsp;variableAlreadyTested,
                   boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean)"><code>countPointsWithinRs(int, double[], boolean)</code></a>
 with an additional factor as follows.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double[],%20boolean)">countPointsWithinRs</a></strong>(int&nbsp;sampleIndex,
                   <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                   int&nbsp;level,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR)</code>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double[],%20boolean,%20int,%20boolean[])">countPointsWithinRs</a></strong>(int&nbsp;sampleIndex,
                   <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                   int&nbsp;level,
                   double[]&nbsp;rs,
                   boolean&nbsp;allowEqualToR,
                   int&nbsp;variableAlreadyTested,
                   boolean[]&nbsp;testResultsForGivenVariable)</code>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findKNearestNeighbours(int,%20int)">findKNearestNeighbours</a></strong>(int&nbsp;K,
                      int&nbsp;sampleIndex)</code>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findKNearestNeighbours(int,%20int,%20int)">findKNearestNeighbours</a></strong>(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      int&nbsp;dynCorrExclTime)</code>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findKNearestNeighbours(int,%20int,%20int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20java.util.PriorityQueue)">findKNearestNeighbours</a></strong>(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      int&nbsp;dynCorrExclTime,
                      <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</code>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findKNearestNeighbours(int,%20int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20java.util.PriorityQueue)">findKNearestNeighbours</a></strong>(int&nbsp;K,
                      int&nbsp;sampleIndex,
                      <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</code>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findNearestNeighbour(int)">findNearestNeighbour</a></strong>(int&nbsp;sampleIndex)</code>
<div class="block">Return the node which is the nearest neighbour for a given
  sample index in the data set.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a></code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findNearestNeighbour(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20infodynamics.utils.NeighbourNodeData)">findNearestNeighbour</a></strong>(int&nbsp;sampleIndex,
                    <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                    int&nbsp;level,
                    <a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;currentBest)</code>
<div class="block">Find the nearest neighbour to a given sample (sampleIndex), in the tree
 rooted at node (which is at the specified level in the tree), or
 return currentBest if no better match is found.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20double,%20boolean)">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however returns a collection rather than a count.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20double,%20int,%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>NearestNeighbourSearcher.findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean,%20boolean[],%20int[],%20int)">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR,
                 int&nbsp;nextIndexInIndicesWithinR)</code>
<div class="block">Record the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean,%20java.util.Collection)">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 boolean&nbsp;allowEqualToR,
                 java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;pointsWithinR)</code>
<div class="block">Add to the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20int,%20boolean,%20boolean[],%20int[],%20int)">findPointsWithinR</a></strong>(int&nbsp;sampleIndex,
                 <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                 int&nbsp;level,
                 double&nbsp;r,
                 int&nbsp;dynCorrExclTime,
                 boolean&nbsp;allowEqualToR,
                 boolean[]&nbsp;isWithinR,
                 int[]&nbsp;indicesWithinR,
                 int&nbsp;nextIndexInIndicesWithinR)</code>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean,%20boolean[],%20int[],%20int)"><code>findPointsWithinR(int, KdTreeNode, int, double, boolean, boolean[], int[], int)</code></a>
  however with dynamic correaltion time specified</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#norm(double[],%20double[],%20int)">norm</a></strong>(double[]&nbsp;x1,
    double[]&nbsp;x2,
    int&nbsp;normToUse)</code>
<div class="block">Computing the configured norm between vectors x1 and x2.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static double</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#normWithAbort(double[],%20double[],%20double,%20int)">normWithAbort</a></strong>(double[]&nbsp;x1,
             double[]&nbsp;x2,
             double&nbsp;limit,
             int&nbsp;normToUse)</code>
<div class="block">Computing the configured norm between vectors x1 and x2; if 
  it becomes clear that norm will be larger than limit,
  then return Double.POSITIVE_INFINITY immediately.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#print()">print</a></strong>()</code>
<div class="block">Internal utility function for debug printing of a tree</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#print(infodynamics.utils.KdTree.KdTreeNode,%20int)">print</a></strong>(<a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
     int&nbsp;level)</code>
<div class="block">Internal utility function for debug printing of a node and
  all of its descendants</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#setNormType(int)">setNormType</a></strong>(int&nbsp;normType)</code>
<div class="block">Set the norm type to use in the nearest neighbour searches,
  to normType.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../infodynamics/utils/KdTree.html#setNormType(java.lang.String)">setNormType</a></strong>(java.lang.String&nbsp;normTypeString)</code>
<div class="block">Set the norm type to use to normType.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_infodynamics.utils.NearestNeighbourSearcher">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;infodynamics.utils.<a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></h3>
<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsStrictlyWithinR(int,%20double)">countPointsStrictlyWithinR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsStrictlyWithinR(int,%20double,%20int)">countPointsStrictlyWithinR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinOrOnR(int,%20double)">countPointsWithinOrOnR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinOrOnR(int,%20double,%20int)">countPointsWithinOrOnR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#create(double[][])">create</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#create(int[],%20double[][][])">create</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double)">findPointsStrictlyWithinR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsStrictlyWithinR(int,%20double,%20boolean[],%20int[])">findPointsStrictlyWithinR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinOrOnR(int,%20double)">findPointsWithinOrOnR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinOrOnR(int,%20double,%20boolean[],%20int[])">findPointsWithinOrOnR</a>, <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#validateNormType(java.lang.String)">validateNormType</a></code></li>
</ul>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="originalDataSets">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>originalDataSets</h4>
<pre>protected&nbsp;double[][][] originalDataSets</pre>
<div class="block">Cached reference to the data the tree is constructed from.
 We have an array of double[][] 2D arrays -- each 2D array 
 originalDataSets[i] is 
 considered as a separate (multivariate) variable (indexed by sample
 number then dimension number), whilst the set of all such
 arrays is considered a joint variable of multivariates.</div>
</li>
</ul>
<a name="masterSortedArrayIndices">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>masterSortedArrayIndices</h4>
<pre>protected&nbsp;int[][] masterSortedArrayIndices</pre>
<div class="block">For each dimension dim, sortedArrayIndices[dim] is an array
  of indices to the data in sourceObservations and destObservations,
  sorted in order (min to max) for the dimension dim;
  plus we have a spare dimension for a temporary array.
 This is only used in the construction of the kd tree.</div>
</li>
</ul>
<a name="dimensionToArray">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimensionToArray</h4>
<pre>protected&nbsp;double[][][] dimensionToArray</pre>
<div class="block">Maps dimension number (first index) to which
  double[][] array holds the data for this dimension,
  and which index we use in that array (dimensionToArrayIndex).
  
 I.e. for a dimension number d (out of the joint variables
 across all the multivariates in originalDataSets), 
 dimensionToArray[d] points to the relevant originalDataSets[i]
 multivariate, while dimensionToArrayIndex[d] tells us which 
 variable within originalDataSets[i] to use, i.e. the time series
 originalDataSets[i][t][dimensionToArrayIndex[d]] for time variable t
 is the relevant time-series for dimension number d.</div>
</li>
</ul>
<a name="dimensionToArrayIndex">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimensionToArrayIndex</h4>
<pre>protected&nbsp;int[] dimensionToArrayIndex</pre>
</li>
</ul>
<a name="dimensionToVariableNumber">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dimensionToVariableNumber</h4>
<pre>protected&nbsp;int[] dimensionToVariableNumber</pre>
<div class="block">Variable at index i in the full joint set 
 corresponds to high level variable
 dimensionToVariableNumber[i]; i.e. the
 originalDataSets[dimensionToVariableNumber[i]] 2D array.</div>
</li>
</ul>
<a name="totalDimensions">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>totalDimensions</h4>
<pre>protected&nbsp;int totalDimensions</pre>
</li>
</ul>
<a name="rootNode">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>rootNode</h4>
<pre>protected&nbsp;<a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a> rootNode</pre>
<div class="block">The root node for this k-d tree</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="KdTree(double[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>KdTree</h4>
<pre>public&nbsp;KdTree(double[][]&nbsp;data)</pre>
<div class="block">Construct the k-d tree from a set of double[][] data.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>data</code> - a double[][] 2D data set, first indexed
  by time, second index by variable number.</dd></dl>
</li>
</ul>
<a name="KdTree(int[], double[][][])">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>KdTree</h4>
<pre>public&nbsp;KdTree(int[]&nbsp;dimensions,
      double[][][]&nbsp;data)</pre>
<div class="block">Construct the k-d tree from a <b>set</b> of double[][] data,
 considered jointly.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>dimensions</code> - an array of dimensions for each
  of the 2D data sets.</dd><dd><code>data</code> - an array of double[][] 2D data sets
  for each data[i]
  (where i is the main variable number within data, then
   after that the first index is sample number, second is dimension
   within this data set)</dd></dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="constructKdTree(int, int, int, int[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constructKdTree</h4>
<pre>protected&nbsp;<a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;constructKdTree(int&nbsp;currentDim,
                                int&nbsp;startPoint,
                                int&nbsp;numPoints,
                                int[][]&nbsp;sortedArrayIndices)</pre>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>currentDim</code> - the dimension that we're currently working with</dd><dd><code>startPoint</code> - the index of the first point for us to add here,
   in the sorted array of points for currentDim</dd><dd><code>numPoints</code> - the number of points for us to add here,
   in the sorted array of points for currentDim</dd><dd><code>sortedArrayIndices</code> - for each dimension dim, sortedArrayIndices[dim] is an array
  of indices to the data in sourceObservations and destObservations,
  sorted in order (min to max) for the dimension dim. This is only valid
  between startPoint and startPoint + numPoints-1 however; nothing outside
  this should be touched. There is one extra dimension here, which may be used
  as a temporary array (though again, only between startPoint and
  startPoint + numPoints-1 should be touched).</dd>
<dt><span class="strong">Returns:</span></dt><dd></dd></dl>
</li>
</ul>
<a name="setNormType(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNormType</h4>
<pre>public&nbsp;void&nbsp;setNormType(int&nbsp;normType)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#setNormType(int)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">Set the norm type to use in the nearest neighbour searches,
  to normType.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#setNormType(int)">setNormType</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>normType</code> - norm type to use; must be either
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a>,
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> or
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_MAX_NORM"><code>EuclideanUtils.NORM_MAX_NORM</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd></dl>
</li>
</ul>
<a name="setNormType(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setNormType</h4>
<pre>public&nbsp;void&nbsp;setNormType(java.lang.String&nbsp;normTypeString)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#setNormType(java.lang.String)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">Set the norm type to use to normType.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#setNormType(java.lang.String)">setNormType</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>normTypeString</code> - norm type to use; must be either
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_STRING</code></a>,
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED_STRING"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED_STRING</code></a> or
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_MAX_NORM_STRING"><code>EuclideanUtils.NORM_MAX_NORM_STRING</code></a>, otherwise an
  UnsupportedOperationException is thrown.
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> will be nominally supported
  but switched to
  <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally for speed.</dd></dl>
</li>
</ul>
<a name="norm(double[], double[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>norm</h4>
<pre>public static final&nbsp;double&nbsp;norm(double[]&nbsp;x1,
          double[]&nbsp;x2,
          int&nbsp;normToUse)</pre>
<div class="block">Computing the configured norm between vectors x1 and x2.
 Adding here instead of using <a href="../../infodynamics/utils/EuclideanUtils.html#norm(double[],%20double[])"><code>EuclideanUtils.norm(double[], double[])</code></a>
 to attempt speed-up.
 Also hoping this method is inlined by the JVM, but haven't checked this.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>x1</code> - vector of doubles</dd><dd><code>x2</code> - vector of doubles</dd>
<dt><span class="strong">Returns:</span></dt><dd>the selected norm</dd></dl>
</li>
</ul>
<a name="normWithAbort(double[], double[], double, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>normWithAbort</h4>
<pre>public static final&nbsp;double&nbsp;normWithAbort(double[]&nbsp;x1,
                   double[]&nbsp;x2,
                   double&nbsp;limit,
                   int&nbsp;normToUse)</pre>
<div class="block">Computing the configured norm between vectors x1 and x2; if 
  it becomes clear that norm will be larger than limit,
  then return Double.POSITIVE_INFINITY immediately.
 
 <p>Adding here instead of using <a href="../../infodynamics/utils/EuclideanUtils.html#normWithAbort(double[],%20double[],%20double)"><code>EuclideanUtils.normWithAbort(double[], double[], double)</code></a>
 to attempt speed-up.
 Also hoping this method is inlined by the JVM, but haven't checked this.</p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>x1</code> - vector 1 of doubles</dd><dd><code>x2</code> - vector 2 of doubles</dd><dd><code>limit</code> - if it becomes clear that norm will be larger than limit,
  then return Double.POSITIVE_INFINITY immediately.</dd><dd><code>normToUse</code> - which norm to use, as defined by <a href="../../infodynamics/utils/KdTree.html#setNormType(int)"><code>setNormType(int)</code></a></dd>
<dt><span class="strong">Returns:</span></dt><dd>the selected norm</dd></dl>
</li>
</ul>
<a name="findNearestNeighbour(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findNearestNeighbour</h4>
<pre>public&nbsp;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;findNearestNeighbour(int&nbsp;sampleIndex)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findNearestNeighbour(int)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">Return the node which is the nearest neighbour for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findNearestNeighbour(int)">findNearestNeighbour</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd>
<dt><span class="strong">Returns:</span></dt><dd>the node for the nearest neighbour.</dd></dl>
</li>
</ul>
<a name="findNearestNeighbour(int, infodynamics.utils.KdTree.KdTreeNode, int, infodynamics.utils.NeighbourNodeData)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findNearestNeighbour</h4>
<pre>protected&nbsp;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;findNearestNeighbour(int&nbsp;sampleIndex,
                                     <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                                     int&nbsp;level,
                                     <a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&nbsp;currentBest)</pre>
<div class="block">Find the nearest neighbour to a given sample (sampleIndex), in the tree
 rooted at node (which is at the specified level in the tree), or
 return currentBest if no better match is found.
 Nearest neighbour is a max norm between the high-level variables,
 with norm for each variable being the specified norm.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>currentBest</code> - a NeighbourNodeData structure capturing the current
  closest neighbour and its distance</dd>
<dt><span class="strong">Returns:</span></dt><dd>the node data for the nearest neighbour.</dd></dl>
</li>
</ul>
<a name="findKNearestNeighbours(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre>public&nbsp;java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours(int&nbsp;K,
                                                                int&nbsp;sampleIndex)
                                                                  throws java.lang.Exception</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findKNearestNeighbours(int,%20int)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findKNearestNeighbours(int,%20int)">findKNearestNeighbours</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>K</code> - number of K nearest neighbours to return, sorted from
  furthest away first to nearest last.</dd><dd><code>sampleIndex</code> - sample index in the data to find the K nearest neighbours
  for</dd>
<dt><span class="strong">Returns:</span></dt><dd>a PriorityQueue of nodes for the K nearest neighbours,
  sorted with furthest neighbour first in the PQ.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="findKNearestNeighbours(int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre>public&nbsp;java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findKNearestNeighbours(int&nbsp;K,
                                                                int&nbsp;sampleIndex,
                                                                int&nbsp;dynCorrExclTime)
                                                                  throws java.lang.Exception</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findKNearestNeighbours(int,%20int,%20int)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">Return the K nodes which are the K nearest neighbours for a given
  sample index in the data set. Nodes within dynCorrExclTime time points
  are excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findKNearestNeighbours(int,%20int,%20int)">findKNearestNeighbours</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>K</code> - number of K nearest neighbours to return, sorted from
  furthest away first to nearest last.</dd><dd><code>sampleIndex</code> - sample index in the data to find the K nearest neighbours
  for</dd><dd><code>dynCorrExclTime</code> - Range around sampleIndex to exclude points from the count. Is >= 0.</dd>
<dt><span class="strong">Returns:</span></dt><dd>a PriorityQueue of nodes for the K nearest neighbours,
  sorted with furthest neighbour first in the PQ.</dd>
<dt><span class="strong">Throws:</span></dt>
<dd><code>java.lang.Exception</code></dd></dl>
</li>
</ul>
<a name="findKNearestNeighbours(int, int, infodynamics.utils.KdTree.KdTreeNode, int, java.util.PriorityQueue)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre>protected&nbsp;void&nbsp;findKNearestNeighbours(int&nbsp;K,
                          int&nbsp;sampleIndex,
                          <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                          int&nbsp;level,
                          java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</pre>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).
 Incorporate neighbours found in this sub-tree into the PriorityQueue
 of the current K closest.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>K</code> - the number of nearest neighbour</dd><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>currentKBest</code> - a PriorityQueue of NeighbourNodeData objects
   capturing the current K closest neighbours and their distances.
   Assumed not to be null, but may be empty or with less than K elements
   so far. It must be sorted from furthest away first to nearest last.</dd></dl>
</li>
</ul>
<a name="findKNearestNeighbours(int, int, int, infodynamics.utils.KdTree.KdTreeNode, int, java.util.PriorityQueue)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findKNearestNeighbours</h4>
<pre>protected&nbsp;void&nbsp;findKNearestNeighbours(int&nbsp;K,
                          int&nbsp;sampleIndex,
                          int&nbsp;dynCorrExclTime,
                          <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                          int&nbsp;level,
                          java.util.PriorityQueue&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;currentKBest)</pre>
<div class="block">Protected method to Update the k nearest neighbours to a given sample (sampleIndex), from the tree
 rooted at node (which is at the specified level in the tree).
 Incorporate neighbours found in this sub-tree into the PriorityQueue
 of the current K closest.
 Make sure to exclude any points within dynCorrExclTime of sampleIndex
  from being included in the k NNs.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>K</code> - the number of nearest neighbour</dd><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>dynCorrExclTime</code> - size of dynamic correlation exclusion time window
  on either side of sampleIndex. 0 means exclude only sampleIndex itself.</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>currentKBest</code> - a PriorityQueue of NeighbourNodeData objects
   capturing the current K closest neighbours and their distances.
   Assumed not to be null, but may be empty or with less than K elements
   so far. It must be sorted from furthest away first to nearest last.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">Count the number of points within norm r for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>protected&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                     int&nbsp;level,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>count of points within r</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     int&nbsp;dynCorrExclTime,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however any nodes within dynCorrExclTime are excluded from
 the search.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20int,%20boolean)">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, int, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>protected&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                     int&nbsp;level,
                     double&nbsp;r,
                     int&nbsp;dynCorrExclTime,
                     boolean&nbsp;allowEqualToR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean)"><code>countPointsWithinR(int, KdTreeNode, int, double, boolean)</code></a>
 however excludes points within dynCorrExclTime of node
 from being counted.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>count of points within r</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public&nbsp;java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                                                        double&nbsp;r,
                                                        boolean&nbsp;allowEqualToR)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean)">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however returns a collection rather than a count.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean)">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>the collection of points within r.</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, boolean, java.util.Collection)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>protected&nbsp;void&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                     <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                     int&nbsp;level,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     java.util.Collection&lt;<a href="../../infodynamics/utils/NeighbourNodeData.html" title="class in infodynamics.utils">NeighbourNodeData</a>&gt;&nbsp;pointsWithinR)</pre>
<div class="block">Add to the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>pointsWithinR</code> - the collection of points to add to</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, boolean, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public&nbsp;void&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;isWithinR,
                     int[]&nbsp;indicesWithinR)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however records the nearest neighbours made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, boolean, boolean[], int[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>protected&nbsp;int&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                    <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                    int&nbsp;level,
                    double&nbsp;r,
                    boolean&nbsp;allowEqualToR,
                    boolean[]&nbsp;isWithinR,
                    int[]&nbsp;indicesWithinR,
                    int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">Record the collection of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).
 
 <p>The recording of nearest neighbours is made within the isWithinR
  and indicesWithinR arrays, which must be constructed before
  calling this method, with length at or exceeding the total
  number of data points. indicesWithinR is 
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd><dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the next available index in indicesWithinR after the method is complete</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, double, int, boolean, boolean[], int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>public&nbsp;void&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     int&nbsp;dynCorrExclTime,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;isWithinR,
                     int[]&nbsp;indicesWithinR)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20int,%20boolean,%20boolean[],%20int[])">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20boolean,%20boolean[],%20int[])"><code>NearestNeighbourSearcher.findPointsWithinR(int, double, boolean, boolean[], int[])</code></a>
 however incorporates dynamic correlation exclusion.
 </p></div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#findPointsWithinR(int,%20double,%20int,%20boolean,%20boolean[],%20int[])">findPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array MUST be passed in with all points set to
  false initially, and is returned indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd></dl>
</li>
</ul>
<a name="findPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, int, boolean, boolean[], int[], int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>findPointsWithinR</h4>
<pre>protected&nbsp;int&nbsp;findPointsWithinR(int&nbsp;sampleIndex,
                    <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                    int&nbsp;level,
                    double&nbsp;r,
                    int&nbsp;dynCorrExclTime,
                    boolean&nbsp;allowEqualToR,
                    boolean[]&nbsp;isWithinR,
                    int[]&nbsp;indicesWithinR,
                    int&nbsp;nextIndexInIndicesWithinR)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#findPointsWithinR(int,%20infodynamics.utils.KdTree.KdTreeNode,%20int,%20double,%20boolean,%20boolean[],%20int[],%20int)"><code>findPointsWithinR(int, KdTreeNode, int, double, boolean, boolean[], int[], int)</code></a>
  however with dynamic correaltion time specified</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>dynCorrExclTime</code> - time window within which to exclude
  points to be counted. Is >= 0. 0 means only exclude sampleIndex.</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>isWithinR</code> - the array should be passed in with all points set to
  false initially, and is return indicating whether each sample was
  found to be within r of that at sampleIndex.</dd><dd><code>indicesWithinR</code> - a list of array indices
  for points marked as true in isWithinR, terminated with a -1 value.</dd><dd><code>nextIndexInIndicesWithinR</code> - the next available index in indicesWithinR
  before the method.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the next available index in indicesWithinR after the method is complete</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, boolean, int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     int&nbsp;variableAlreadyTested,
                     boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean)"><code>countPointsWithinR(int, double, boolean)</code></a>
 with an additional factor as follows.
 
 <p>For this method, one of the high-level variables has already had their
 norms tested against r; this variable is indicated by variableAlreadyTested
 and the results are contained in the testResultsForGivenVariable array.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsStrictlyWithinR(int, double, int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsStrictlyWithinR(int&nbsp;sampleIndex,
                             double&nbsp;r,
                             int&nbsp;variableAlreadyTested,
                             boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean,%20int,%20boolean[])"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinOrOnR(int, double, int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinOrOnR(int&nbsp;sampleIndex,
                         double&nbsp;r,
                         int&nbsp;variableAlreadyTested,
                         boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinR(int,%20double,%20boolean,%20int,%20boolean[])"><code>countPointsWithinR(int, double, boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, boolean, int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>protected&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                     int&nbsp;level,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     int&nbsp;variableAlreadyTested,
                     boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within r for each
   sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>count of points within r</dd></dl>
</li>
</ul>
<a name="countPointsWithinRs(int, double[], boolean, int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinRs(int&nbsp;sampleIndex,
                      double[]&nbsp;rs,
                      boolean&nbsp;allowEqualToR,
                      int&nbsp;variableAlreadyTested,
                      boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean)"><code>countPointsWithinRs(int, double[], boolean)</code></a>
 with an additional factor as follows.
 
 <p>For this method, one of the high-level variables has already had their
 norms tested against the relevant r; this variable is indicated by variableAlreadyTested
 and the results are contained in the testResultsForGivenVariable array.
 </p></div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>rs</code> - radii for each variable within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radii rs also,
   otherwise only those strictly within rs</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within rs.</dd></dl>
</li>
</ul>
<a name="countPointsStrictlyWithinRs(int, double[], int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinRs</h4>
<pre>public&nbsp;int&nbsp;countPointsStrictlyWithinRs(int&nbsp;sampleIndex,
                              double[]&nbsp;rs,
                              int&nbsp;variableAlreadyTested,
                              boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean,%20int,%20boolean[])"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == false</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>rs</code> - radii for each variable within which to count points</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within rs.</dd></dl>
</li>
</ul>
<a name="countPointsWithinOrOnRs(int, double[], int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnRs</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinOrOnRs(int&nbsp;sampleIndex,
                          double[]&nbsp;rs,
                          int&nbsp;variableAlreadyTested,
                          boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">As per <a href="../../infodynamics/utils/KdTree.html#countPointsWithinRs(int,%20double[],%20boolean,%20int,%20boolean[])"><code>countPointsWithinRs(int, double[], boolean, int, boolean[])</code></a>
 with allowEqualToR == true</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>rs</code> - radii for each variable within which to count points</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within rs.</dd></dl>
</li>
</ul>
<a name="countPointsWithinRs(int, infodynamics.utils.KdTree.KdTreeNode, int, double[], boolean, int, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre>protected&nbsp;int&nbsp;countPointsWithinRs(int&nbsp;sampleIndex,
                      <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      double[]&nbsp;rs,
                      boolean&nbsp;allowEqualToR,
                      int&nbsp;variableAlreadyTested,
                      boolean[]&nbsp;testResultsForGivenVariable)</pre>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 when one of the variables has already been tested.
 The node itself is excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>rs</code> - radii for each variable within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>variableAlreadyTested</code> - the variable for which the test results
   are provided in testResultsForGivenVariable</dd><dd><code>testResultsForGivenVariable</code> - array of booleans indicating whether
   the variable identified by variableAlreadyTested was within rs[variableAlreadyTested]
   for each sample index.</dd>
<dt><span class="strong">Returns:</span></dt><dd>count of points within rs</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, double, boolean, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;additionalCriteria)</pre>
<div class="block"><strong>Description copied from class:&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean,%20boolean[])">NearestNeighbourSearcher</a></code></strong></div>
<div class="block">As per <a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean)"><code>NearestNeighbourSearcher.countPointsWithinR(int, double, boolean)</code></a>
 however each point is subject to also meeting the additional
 criteria of being true in additionalCriteria.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html#countPointsWithinR(int,%20double,%20boolean,%20boolean[])">countPointsWithinR</a></code>&nbsp;in class&nbsp;<code><a href="../../infodynamics/utils/NearestNeighbourSearcher.html" title="class in infodynamics.utils">NearestNeighbourSearcher</a></code></dd>
<dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinR(int, infodynamics.utils.KdTree.KdTreeNode, int, double, boolean, boolean[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinR</h4>
<pre>protected&nbsp;int&nbsp;countPointsWithinR(int&nbsp;sampleIndex,
                     <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                     int&nbsp;level,
                     double&nbsp;r,
                     boolean&nbsp;allowEqualToR,
                     boolean[]&nbsp;additionalCriteria)</pre>
<div class="block">Count the number of points within radius r of a given sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree),
 subject to an additional criteria.
 Nearest neighbour function to compare to r is a max norm between the
 high-level variables, with norm for each variable being the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>r</code> - radius within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radius r also,
   otherwise only those strictly within r</dd><dd><code>additionalCriteria</code> - array of booleans. Only count a point if it
  is within r and is true in additionalCrtieria.</dd>
<dt><span class="strong">Returns:</span></dt><dd>count of points within r</dd></dl>
</li>
</ul>
<a name="countPointsWithinRs(int, double[], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinRs(int&nbsp;sampleIndex,
                      double[]&nbsp;rs,
                      boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>rs</code> - radii for each variable within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radii rs also,
   otherwise only those strictly within rs</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within rs.</dd></dl>
</li>
</ul>
<a name="countPointsStrictlyWithinRs(int, double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsStrictlyWithinRs</h4>
<pre>public&nbsp;int&nbsp;countPointsStrictlyWithinRs(int&nbsp;sampleIndex,
                              double[]&nbsp;rs)</pre>
<div class="block">Count the number of points strictly within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>rs</code> - radii for each variable within which to count points</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinOrOnRs(int, double[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinOrOnRs</h4>
<pre>public&nbsp;int&nbsp;countPointsWithinOrOnRs(int&nbsp;sampleIndex,
                          double[]&nbsp;rs)</pre>
<div class="block">Count the number of points within or at norms {r1,r2,etc} for each high-level
  variable, for a given
  sample index in the data set. The node itself is 
  excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>rs</code> - radii for each variable within which to count points</dd>
<dt><span class="strong">Returns:</span></dt><dd>the count of points within or on r.</dd></dl>
</li>
</ul>
<a name="countPointsWithinRs(int, infodynamics.utils.KdTree.KdTreeNode, int, double[], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>countPointsWithinRs</h4>
<pre>protected&nbsp;int&nbsp;countPointsWithinRs(int&nbsp;sampleIndex,
                      <a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
                      int&nbsp;level,
                      double[]&nbsp;rs,
                      boolean&nbsp;allowEqualToR)</pre>
<div class="block">Count the number of points within norms {r1,r2,etc} for each high-level
  variable, for a given
  sample (sampleIndex),
 in the tree rooted at node (which is at the specified level in the tree).
 The node itself is excluded from the search.
 Nearest neighbour function to compare to {r1,r2,etc}
  for each variable is the specified norm.
 (If <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN"><code>EuclideanUtils.NORM_EUCLIDEAN</code></a> was selected, then the supplied
 r should be the required Euclidean norm <b>squared</b>, since we switch it
 to <a href="../../infodynamics/utils/EuclideanUtils.html#NORM_EUCLIDEAN_SQUARED"><code>EuclideanUtils.NORM_EUCLIDEAN_SQUARED</code></a> internally).</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>sampleIndex</code> - sample index in the data to find a nearest neighbour
  for</dd><dd><code>node</code> - node to start searching from in the kd-tree. Cannot be null</dd><dd><code>level</code> - which level we're currently at in the tree</dd><dd><code>rs</code> - radii for each variable within which to count points</dd><dd><code>allowEqualToR</code> - if true, then count points at radii rs also,
   otherwise only those strictly within r</dd>
<dt><span class="strong">Returns:</span></dt><dd>count of points within r</dd></dl>
</li>
</ul>
<a name="print()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>print</h4>
<pre>public&nbsp;void&nbsp;print()</pre>
<div class="block">Internal utility function for debug printing of a tree</div>
</li>
</ul>
<a name="print(infodynamics.utils.KdTree.KdTreeNode, int)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>print</h4>
<pre>protected&nbsp;void&nbsp;print(<a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils">KdTree.KdTreeNode</a>&nbsp;node,
         int&nbsp;level)</pre>
<div class="block">Internal utility function for debug printing of a node and
  all of its descendants</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>node</code> - current node</dd><dd><code>level</code> - which level we're at in the tree</dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../infodynamics/utils/IntArrayWrapper.html" title="class in infodynamics.utils"><span class="strong">Prev Class</span></a></li>
<li><a href="../../infodynamics/utils/KdTree.KdTreeNode.html" title="class in infodynamics.utils"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?infodynamics/utils/KdTree.html" target="_top">Frames</a></li>
<li><a href="KdTree.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
